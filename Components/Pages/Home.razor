@using System.Net.WebSockets
@using System.Net
@using System.Text
@using System.Text.Json
@using System.Numerics
@using System.Drawing

@page "/"
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Home</PageTitle>

<div class="ws-header">
    @if (error != null) {
        <h1>@error</h1>
    } else if (isLoading) {
        <h1>Connecting to WS</h1>
    } else {
        <h1>Connected to WS</h1>
    }
</div>
<div class="ws-body">
    @if (!isLoading) {
    <div id="game" style=@GetGameBoxStyles()>
        @foreach (var styles in GetPlayersStyles()) {
            <div style=@styles></div>
        }
    </div>
    }
</div>

@code {
    private DotNetObjectReference<Home> dotNetRef;
    private ClientWebSocket websocket;
    private HttpClient http;
    private GameData gameData;
    private string token;
    private Dictionary<Actions, bool> actions = new() {
        {Actions.ROTATE_LEFT, false},
        {Actions.ROTATE_RIGHT, false},
        {Actions.ACCELERATE, false},
        {Actions.DECELERATE, false},
    };
    private int index;
    private bool isLoading = true;
    private bool isUpdating = false;
    private string? error;
    private void ClearMessages() {
        StateHasChanged();
    }
    [JSInvokable]
    public async Task OnKeyDown(string key) {
        switch (key) {
            case "w": {
                actions[Actions.ACCELERATE] = true;
                break;
            }
            case "a": {
                actions[Actions.ROTATE_LEFT] = true;
                break;
            }
            case "s": {
                actions[Actions.DECELERATE] = true;
                break;
            }
            case "d": {
                actions[Actions.ROTATE_RIGHT] = true;
                break;
            }
        }
    }
    [JSInvokable]
    public async Task OnKeyUp(string key) {
        switch (key) {
            case "w": {
                actions[Actions.ACCELERATE] = false;
                break;
            }
            case "a": {
                actions[Actions.ROTATE_LEFT] = false;
                break;
            }
            case "s": {
                actions[Actions.DECELERATE] = false;
                break;
            }
            case "d": {
                actions[Actions.ROTATE_RIGHT] = false;
                break;
            }
        }
    }
    private async Task HandleActions() {
        Vector2 newSpeed;
        ActionData action = new() {Token = token, Actions = actions};

        lock (gameData) {
            gameData.ApplyAction(action.Actions, index);
            StateHasChanged();
        }
        
        var json = JSON.Stringify(action);
        var bytes = Encoding.ASCII.GetBytes(json);

        await websocket.SendAsync(bytes, WebSocketMessageType.Text, true, CancellationToken.None);
    }
    private List<string> GetPlayersStyles() {
        var playersStyle = new List<string>(gameData.Players.Count);
        foreach (var player in gameData.Players) {
            var angle = Math.Atan2(player.SpeedDirection.Y, player.SpeedDirection.X) * (180 / Math.PI);
            var styles = new List<string> {
                "position: absolute",
                $"top: {player.Position.Y}px",
                $"left: {player.Position.X}px",
                "background-color: black",
                "width: 0",
                "height: 0",
                "border-left: 10px solid white",
                "border-right: 10px solid white",
                "border-bottom: 20px solid black",
                $"transform: rotate({angle + 90}deg)",
                "transform-origin: center",
                "will-change: transform"
            };
            playersStyle.Add(string.Join(';', styles));
        }
        return playersStyle;
    }
    private string GetGameBoxStyles() {
        if (gameData == null) return "";
        var styles = new List<string> {
            "position: absolute",
            $"width: {gameData.FieldWidth}px",
            $"height: {gameData.FieldHeight}px",
            "border: 1px solid black",
            "overflow: hidden"
        };
        return string.Join(';', styles);
    }
    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender) return;

        dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("keyPressHandler.initialize", dotNetRef);

        error = null;
        isLoading = true;
        
        var httpURI = new Uri("http://localhost:5168/metadata");
        http = new HttpClient();

        try {
            var response = await http.GetAsync(httpURI);
            var body = await response.Content.ReadAsStringAsync();
            if (response.StatusCode != HttpStatusCode.OK) {
                error = body;
            } else {
                var tokenHeaderElements = response.Headers.GetValues("token").First().Split("///");
                index = int.Parse(tokenHeaderElements[0]);
                token = tokenHeaderElements[1];
                gameData = JSON.Parse<GameData>(body);
            }
        } catch (Exception ex) {
            error = $"Failed to fetch metadata: {ex.Message}";
        }

        StateHasChanged();

        if (error != null) return;

        var wsURI = new Uri("ws://localhost:5168/ws");
        websocket = new ClientWebSocket();

        try {
            var token = new CancellationTokenSource(5000).Token;
            await websocket.ConnectAsync(wsURI, CancellationToken.None);
            
            isLoading = false;
            StateHasChanged();

            var loopTask = Loop();
            await HandleWebSocket();
        } catch (OperationCanceledException) {
            error = "WebSocket connection timedout";
        } catch (Exception ex) {
            if (ex.Message.Contains("429")) {
                error = "WebSocket hub is full"; 
            } else {
                error = $"Failed to connect to WebSocket: {ex.Message}";
            }
            StateHasChanged();
        }
    }
    private async Task HandleWebSocket() {
        var buffer = new byte[1024 * 4];
        while (websocket?.State == WebSocketState.Open) {
            try {
                var result = await websocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

                if (result.MessageType == WebSocketMessageType.Close) {
                    await websocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
                    break;
                }

                var message = Encoding.UTF8.GetString(buffer, 0, result.Count);
                var newTransforms = JSON.Parse<List<Transform>>(message);
                lock (gameData) {
                    gameData.Players = newTransforms;
                }
            } catch (Exception ex) {
                error = $"WebSocket error: {ex.Message}";
            } finally {
                StateHasChanged();
            }
        }
    }
    private async Task Loop() {
        while (true) {
            await Task.Delay(Constants.gameThreadWaitTime);
            await HandleActions();
            lock (gameData) {
                for (int i = 0; i < gameData.Players.Count; i++) {
                    gameData.Players[i].UpdateSelf(Constants.gameThreadWaitTime / 1000);
                }
            }
            StateHasChanged();
        }
    }
    public async Task DisposeAsync() {
        if (websocket != null && websocket.State == WebSocketState.Open) {
            await websocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Component disposed", CancellationToken.None);
        }
        websocket?.Dispose();
        dotNetRef?.Dispose();
    }
}