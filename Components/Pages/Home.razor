@using System.Net.WebSockets
@using System.Net
@using System.Text
@using System.Text.Json
@using System.Numerics
@using System.Drawing

@page "/"
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Home</PageTitle>

<div class="ws-header">
    @if (error != null) {
        <h1>@error</h1>
    } else if (isLoading) {
        <h1>Connecting to WS</h1>
    } else {
        <h1>Connected to WS</h1>
    }
</div>
<div class="ws-body">
    @if (!isLoading) {
    <div id="game" style=@GetGameBoxStyles() @onclick="HandleClick">
        @foreach (var styles in GetPlayersStyles()) {
            <div style=@styles></div>
        }
    </div>
    }
</div>

@code {
    private ClientWebSocket websocket;
    private HttpClient http;
    private GameData gameData;
    private string token;
    private int index;
    private bool isLoading = true;
    private bool isUpdating = false;
    private string? error;
    private void ClearMessages() {
        StateHasChanged();
    }
    private async Task HandleClick(MouseEventArgs e) {
        Vector2 newSpeed;
        var elementRect = await JSRuntime.InvokeAsync<ElementRect>("GetBoundingBoxByID", "game");
        var mouseX = (float)(e.ClientX - elementRect.Left);
        var mouseY = (float)(e.ClientY - elementRect.Top);

        lock (gameData) {
            var clickDirection = Vector2.Normalize(new Vector2(mouseX, mouseY) - gameData.Players[index].Position);
            var magnitude = gameData.Players[index].Speed.Length();
            
            var newDirection = clickDirection + Vector2.Normalize(gameData.Players[index].Speed);
            newSpeed = Vector2.Normalize(newDirection) * magnitude; 
            
            gameData.Players[index].Speed = newSpeed;
        }
        
        var data = new NewSpeedData { Speed = newSpeed, Token = token };
        var json = JSON.Stringify(data);
        var bytes = Encoding.ASCII.GetBytes(json);

        await websocket.SendAsync(bytes, WebSocketMessageType.Text, true, CancellationToken.None);
    }
    private List<string> GetPlayersStyles() {
        var playersStyle = new List<string>(gameData.Players.Count);
        foreach (var player in gameData.Players) {
            var styles = new List<string> {
                "position: absolute",
                $"top: {player.Position.Y}px",
                $"left: {player.Position.X}px",
                "background-color: black",
                "width: 10px",
                "height: 10px"
            };
            playersStyle.Add(string.Join(';', styles));
        }
        return playersStyle;
    }
    private string GetGameBoxStyles() {
        if (gameData == null) return "";
        var styles = new List<string> {
            "position: absolute",
            $"width: {gameData.FieldWidth}px",
            $"height: {gameData.FieldHeight}px",
            "border: 1px solid black",
            "overflow: hidden"
        };
        return string.Join(';', styles);
    }
    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender) return;

        error = null;
        isLoading = true;
        
        var httpURI = new Uri("http://localhost:5168/metadata");
        http = new HttpClient();

        try {
            var response = await http.GetAsync(httpURI);
            var body = await response.Content.ReadAsStringAsync();
            if (response.StatusCode != HttpStatusCode.OK) {
                error = body;
            } else {
                var tokenHeaderElements = response.Headers.GetValues("token").First().Split("///");
                index = int.Parse(tokenHeaderElements[0]);
                token = tokenHeaderElements[1];
                gameData = JSON.Parse<GameData>(body);
            }
        } catch (Exception ex) {
            error = $"Failed to fetch metadata: {ex.Message}";
        }

        StateHasChanged();

        if (error != null) return;

        var wsURI = new Uri("ws://localhost:5168/ws");
        websocket = new ClientWebSocket();

        try {
            var token = new CancellationTokenSource(5000).Token;
            await websocket.ConnectAsync(wsURI, CancellationToken.None);
            
            isLoading = false;
            StateHasChanged();

            var loopTask = Loop();
            await HandleWebSocket();
        } catch (OperationCanceledException) {
            error = "WebSocket connection timedout";
        } catch (Exception ex) {
            if (ex.Message.Contains("429")) {
                error = "WebSocket hub is full"; 
            } else {
                error = $"Failed to connect to WebSocket: {ex.Message}";
            }
            StateHasChanged();
        }
    }
    private async Task HandleWebSocket() {
        var buffer = new byte[1024 * 4];
        while (websocket?.State == WebSocketState.Open) {
            try {
                var result = await websocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);

                if (result.MessageType == WebSocketMessageType.Close) {
                    await websocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
                    break;
                }

                var message = Encoding.UTF8.GetString(buffer, 0, result.Count);
                var newTransforms = JSON.Parse<List<Transform>>(message);
                lock (gameData) {
                    gameData.Players = newTransforms;
                }
            } catch (Exception ex) {
                error = $"WebSocket error: {ex.Message}";
            } finally {
                StateHasChanged();
            }
        }
    }
    private async Task Loop() {
        while (true) {
            await Task.Delay(Constants.gameThreadWaitTime);
            lock (gameData) {
                for (int i = 0; i < gameData.Players.Count; i++) {
                    gameData.Players[i].UpdateSelf(Constants.gameThreadWaitTime / 1000);
                }
            }
            StateHasChanged();
        }
    }
    public async Task DisposeAsync() {
        if (websocket != null && websocket.State == WebSocketState.Open) {
            await websocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Component disposed", CancellationToken.None);
        }
        websocket?.Dispose();
    }
}